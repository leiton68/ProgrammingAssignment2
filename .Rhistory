x
x <- c(3,5,1,10,12,6)
x[x!=6] <- 0
x
x <- c(3,5,1,10,12,6)
x[x>=6] <- 0
x
x <- c(3,5,1,10,12,6)
x[x%in% 1:5] <- 0
x
x <- c(3,5,1,10,12,6)
x[x==6] <- 0
x
data <- read.table("C:\Users\LEITON\Desktop\CURSO R COURSERA\01SEMANA\hw1_data.csv")
getwd()
getwd()
data <- read.table("hw1_data.csv")
data <- read.csv("hw1_data.csv")
data
data[1]
data[,1]
data
data[Ozone]
data['Ozone']
data['Ozone',47]
data['Ozone',153]
data['Ozone'][47]
data['Ozone']
data['Ozone'].mean()
data[[1][1]]
data[[1]][[1]]
data[['Oxone']][[1]]
data[['Oxone']][[2]]
data[['Ozone']][[2]]
data[['Ozone']][[47]]
data[['Ozone']]
is.na(data[['Ozone']])
zz1 <- is.na(data[['Ozone']])
zz1
u <- zz1==TRUE
u
zz1[u]
data[u]
u1 <- zz1==FALSE
u1
zz <- (data[['Ozone']])
zz
zz[u1]
mean(zz[u1])
zz2 <- (zz[u1] >31 & zz[u1] <90)
zz2
zz[zz2]
data
zz5 <- (data[['Month']]==5)
zz5
data[zz5]
uu1 <- data
uu1[zz5]
uu1
data[['Month']]==5
uu2 <- uu1==TRUE
uu1[uu2]
uu1
zz1 <- is.na(data[['Ozone']])
zz1
u <- zz1 = TRUE
u <- zz1 == TRUE
data[u]
zz <- (data[['Ozone']])
zz[u]
(data[['Ozone']])
oz <- (data[['Ozone']])
zz1 <- is.na(data[['Ozone']])
zz1
u <- zz1 == TRUE
u
oz[u]
zz1[u]
data[u]
data
data %>% filter(Monh == 6)
data %>% filter(Month == 6)
data
data['Month']
f1 <- data['Month']
f2 <- f1 == 6
f2
f3 <- f2==TRUE
f1[f3]
data[f1[f3]]
data
f1 <- is.na(data['Ozone'])
data[!['Ozone']]
data[!f1]
f1
u1 <- data['Ozone']
u1[!f2]
u1[!f3]
data
data[32:61]
data[32,61]
data[,,,,32:61,,]
data[32:61,32:61,32:61,32:61,32:6132:61]
filter(data,"Ozone"=na)
filter(data,"Ozone"==na)
filter(data,"Month"==69
filter(data,"Ozone"==na)
filter(data,"Month"==6)
filter(data,Month==6)
data
d1 <- filter(data,Month==6)
d1 <- filter(data,"Month"==6)
d1
data %>% filter(Month==6)
library(dplyr)
data[,[1:3]]
data[1]
data[,3]
data[,1]
data
data[,4]
data[,4][1_6]
data[,4][1:6]
data[,4]["Month"==6]
data[,4][32:61]
mean(data[,4][32:61])
x <- c(1,3, 5)
y <- c(3, 2, 10)
rbind(x,y)
add2(3,5)
x+y
add2(3,5)
add2 <- function(x,y){
x + y
}
add2(3,5)
above <- function(x,n) {
use <- x > n
x[use]
x <- 1:20
above(x)
above(x,12)
above(x,12)
above <- function(x,n=10) {
use <- x > n
x[use]
}
above(x,12)
above(x)
x <- 1:20
above(x)
above <- function(x, n = 10) {
use <- x > n
x[use]
}
1+1
1+1
add2(3,5)
add2(3,5)
add2(3,5)
1+1
0
1+1
x <- 1
x
above <- function(x, n = 10) {
use <- x > n
x[use]
}
x <- 1:20
above(x)
above(x,12)
columnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <-mean(y[,i])
}
means
}
columnmean(airequality)
columnmean(airquality)
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <-mean(y[,i], na.rm =removeNA)
}
means
}
columnmean(airquality)
columnmean(airquality,FALSE)
swirl()
install.packages("swirl")
packageVersion("swirl")
library(swirl)
swirl()
library("swirl")
install_course("Notificaciones
R Programming")
install_from_swirl("R Programming")
x <- list(a = 1:5, b = rnorm(10))
lapply(x, mean)
x
rnorm(10)
lapply(x, mean)
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20,1), d = rnorm(100,5))
lapply(x, mean)
c
d
x
x <- 1:4
lapply(x, runif)
x <- 1:4
lapply(x, runif, min = 0, max = 10)
x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2))
x
lapply(x, function(elt) elt[,1])
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20,1), d = rnorm(100,5))
sapply(x, mean)
mean(x)
x <- matrix(rnorm(200), 20, 10)
x
apply(x, 2, mean)
apply(x, 1, sum)
x <- matrix(rnorm(200), 20, 10)
apply(x, 1, quantile, probs = c(0.25, 0.75))
a <- array(rnorm(2*2*10),c(2,2,10))
apply(a, c(1,2), mean)
rowMeans(a, dims = 2)
a
rowMeans(a, dims = 2)
mapply(rep, 1:4, 4:1)
noise <- function(n, mean, sd){}
noise <- function(n, mean, sd){ rnorm(n,mean,sd)}
noise(5,1,2)
noise(1:5,1:5,2)
mapply(noise, 1:5,1:5,2)
x <- c(rnorm(10), runif(10), rnorm(10,1))
f <- gl(3, 10)
f
tapply(x,f,mean)
x
f
tapply(x,f,mean, simplify=FALSE)
tapply(x,f,range)
x <- c(rnorm(10), runif(10), rnorm(10,1))
x
f <- gl(3,10)
f
split(x,f)
lapply(split(X,f), mean)
log(-1)
printmessage <- function(x){
if(x>0)
print("x is greater than zero")
else
print("x es less than or equal to zero")
invisible(x)
}
printmessage(1)
printmessage(NA)
printmessage2 <- function(x){
if(is.na(x))
print("x is a missing value!")
else if(x>0)
print("x is greater than zero")
else
print("x es less than or equal to zero")
invisible(x)
}
printmessage2(x)
x <- log(-1)
printmessage2(x)
mean(x)
clear all
clear
mean(x)
mean(x)
x
x
x
mean(x)
traceback()
lm(y-x)
traceback()
help lm
debug(lm)
lm(y-x)
option(error = recover)
read.csv("nosuchfile")
options(error = recover)
read.csv("nosuchfile")
library(datasets)
data(iris)
?iris
iris
mean(Sepal.Length)
library(datasets)
data(iris)
library(datasets)
data(iris)
?iris
iris
iris[1]
iris[1,101:150]
2
apply(iris,1,mean)
apply(iris,2,mean)
iris
apply(iris,1,mean)
apply(iris,3,mean)
apply(iris, 1, mean)
library(datasets)
data("iris")
?iris
iris_dt <- as.data.table(iris)
iris_dt[Species == "virginica", round(mean(Sepal.Length))]
iris
install.packages("data.table")
iris_dt <- as.data.table(iris)
iris_dt[Species == "virginica", round(mean(Sepal.Length))]
iris_dt <- as.data.table(iris)
iris_dt[Species == "virginica", round(mean(Sepal.Length))]
iris_dt <- as.data.table(iris)
library(datasets)
data(iris)
iris
library(data.table)
iris_dt <- as.data.table(iris)
iris_dt[Species == "virginica", round(mean(Sepal.Length))]
iris_dt[Species == "virginica", round(mean(Sepal.Length))]
iris_dt[Species == "virginica", round(mean(Sepal.Length),3)]
iris_dt[Species == "virginica", round(mean(Sepal.Length),4)]
apply(iris,1,mean)
apply(iris[,1:4],2,mean)
apply(iris, 2, mean)
apply(iris[,1:4],1,mean)
colMeans(iris)
rowMeans(iris[,1:4])
library(datasets)
data(mtcars)
?mtcars
mtcars
with(mtcars, tapply(mpg, cyl, mean))
sapply(mtcars, cyl, mean)
split(mtcars, mtcars$cyl)
lapply(mtcars, mean)
apply(mtcars, 2, mean)}
apply(mtcars, 2, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
sapply(split(mtcars$mpg, mtcars$cyl),mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
mean(mtcars$mpg, mtcars$cyl)
mtcars
with(mtcars, tapply(hp, cyl, mean))
209.21429-82.63636
debug(ls)
x <<- 1
x
setwd
dir
getwd
getwd()
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
getwd()
load("C:/Users/LEITON/ProgrammingAssignment2/ProgrammingAssignment2/cachematrix.R")
getwd()
setwd("C:/Users/LEITON/ProgrammingAssignment2/ProgrammingAssignment2")
getwd()
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
## This function creates a matrix object that can cache its inverse
makeCacheMatrix <- fucntion(x=matrix()){
inv <- NULL
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function computes the inverse of the matrix created in the function
## above.
cacheSolve <- function(x, ...){
## Return inverse matrix of x
inv <- x$getInverse()
if (!is.null(j)){
message("getting cached data")
return(inv)
}
mat <- x$get()
j <- solve(mat, ...)
x$setInverse(inv)
inv
}
## This function creates a matrix object that can cache its inverse
makeCacheMatrix <- function(x=matrix()){
inv <- NULL
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function computes the inverse of the matrix created in the function
## above.
cacheSolve <- function(x, ...){
## Return inverse matrix of x
inv <- x$getInverse()
if (!is.null(j)){
message("getting cached data")
return(inv)
}
mat <- x$get()
j <- solve(mat, ...)
x$setInverse(inv)
inv
}
getwd()
my_matrix <- makeCacheMatrix(matrix(1:4),2,2))
my_matrix <- makeCacheMatrix(matrix(1:4,2,2))
my_matrix$get()
my_matrix$getInerse()
my_matrix$getInverse()
cacheSolve(my_matrix)
## This function creates a matrix object that can cache its inverse
makeCacheMatrix <- function(x=matrix()){
inv <- NULL
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function computes the inverse of the matrix created in the function
## above.
cacheSolve <- function(x, ...){
## Return inverse matrix of x
inv <- x$getInverse()
if (!is.null(j)){
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
getwd()
my_matrix <- makeCacheMatrix(matrix(1:4,2,2))
my_matrix$get()
my_matrix$getInverse()
cacheSolve(my_matrix)
## This function creates a matrix object that can cache its inverse
makeCacheMatrix <- function(x=matrix()){
inv <- NULL
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function computes the inverse of the matrix created in the function
## above.
cacheSolve <- function(x, ...){
## Return inverse matrix of x
inv <- x$getInverse()
if (!is.null(inv)){
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
my_matrix <- makeCacheMatrix(matrix(1:4,2,2))
my_matrix$get()
my_matrix$getInverse()
cacheSolve(my_matrix)
cacheSolve(my_matrix)
cacheSolve(my_matrix)
my_matrix$getInverse()
my_matrix <- makeCacheMatrix(matrix(c(2,2,1,4),2,2))
my_matrix$get()
my_matrix$getInverse()
cacheSolve(my_matrix)
cacheSolve(my_matrix)
my_matrix$getInverse()
